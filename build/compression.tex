\chapter{Compressing Signatures}
\label{sec:compress}

Our second contribution, also in the form of an addition to the \sidh signature extension, is a mechanism for compressing signatures. The following Chapter will cover the compression technique used. This Chapter, much like the last, will be split into three Sections: a brief coverage of the employed compression technique, the details of our implementation and integration of this technique into \sidh, and finally an analysis of the results of this contribution.

In the first Section of this Chapter, we discuss the SIDH public key compression technique outlined in \cite{pkcomp}. We attempt to provide a sufficient overview of the technique while only covering in detail the components that are of significant relevance to our implementation. For those who seek to better understand the ins and outs of this technique should direct themselves to the original paper.  

The second Section covers in detail how we apply this public key compression to Yoo et al. signatures. 

Finally, we round off the Chapter with an analysis of the memory improvement offered by this technique. We contrast this spatial improvement with the computational cost of compressing points, and discuss the practicality of employing this technique. 

\section{SIDH Key Compression Background}

Costello et al. showed in \cite{pkcomp} that  
We discussed rejection sampling A values from signature public keys until we found an A that was also the x-coord of a point. After some simple analysis, however, we found that it was extremely unlikely for A to be a point on the curve.

\subsection{Construction of Bases}

\subsection{Pohlig-Hellman}

\subsection{Decompression}

\section{Implementation Details}
\label{sec:compimplementation}

\subsection{Implementation Details}

\subsection{$\psi(S)$ Compression}

\noindent
\textit{Potential Tradeoffs}.

\section{Results}

Our technique can reduce the size of \sidh signature compression from \_\_\_ bits to \_\_\_ bits.

\subsection{Analysis}

\subsection{Potential Performance Improvements}

could use a non-constant implementation of double and add instead of montgomery's ladder? 

