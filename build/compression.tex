\chapter{Compressing Signatures}
\label{sec:compress}

Our second contribution, also in the form of an addition to the \sidh signature extension, is a mechanism for compressing signatures. The following chapter will cover the compression technique used. This chapter, much like the last, will be split into three sections: a brief coverage of the employed compression technique, the details of our implementation and integration of this technique into \sidh, and finally an analysis of the results of this contribution.

In the first section of this chapter, we discuss the SIDH public key compression technique outlined in \cite{compwr}. We attempt to provide a sufficient overview of the technique while only covering in detail the components that are of significant relevance to our implementation. For those who seek to better understand the ins and outs of this technique should direct themselves to the original paper.  

The second Section covers in detail how we apply this public key compression to Yoo et al. signatures. We make use of the functions offered in \cite{pkcomp} which implement the methods of \cite{compwr} for public key compression. This code was first made available in the second installment of Microsoft's SIDH library.

Finally, we round off the Chapter with an analysis of the memory improvement offered by this technique. We contrast this spatial improvement with the computational cost of compressing points, and discuss the practicality of employing this technique. 

\section{SIDH Key Compression Background}

Recall from Section \ref{subsec:sidhkex} the structure of an SIDH public key, denoted $pk$;
$$
pk = (E, P, Q)
$$
Where $E$ is a supersingular elliptic curve and $P$ and $Q$ are elliptic curve points such that $P, Q \in E$. Recall that E can be represented logically by one $\mathbb{F}_{p}$ element which denotes $A$ from the following definition of $E$:
$$
E : y^2 = x^3 + Ax + B,
$$

$A$ sufficiently represents $E$ in this context because in \sidh we are concerned only with curves where $B$ = 0. 

$P$ and $Q$, on the other hand, can each be represented by their $x$-coordinate (two $\mathbb{F}_{p}$ elements) and a single bit determining the correct $y$-coordinate. Therefore, this approach can represent SIDH public keys with $~6\log p$ bits.

\subsection{Compression}

Azerderakhsh et al. showed in \cite{compwr} that the size of $pk$ can be further compressed to $4\log p$ bits. Consider the following.

Given $P \in E[\ell]$, $P$ can be represented by elements $\alpha, \beta \in \mathbb{Z}/\ell\mathbb{Z}$. These elements are computed as the coefficients of $P$ with respect to some fixed basis $\{R_1, R_2\}$ in the following manner: 
$$
P = \alpha R_1 + \beta R_2,
$$

Assuming $\alpha$ is invertible, we then have

$$
P = R_1 + \alpha^{-1}\beta R_2
$$

And so, as long as \alice and \bob can agree on a basis $\{R_1, R_2\}$ they can both sufficiently represent one anothers public keys with only 

\noindent
\textit{Constructing the Basis}.\\

\noindent
\textit{Pohleg-Hellman}.

\subsection{Decompression}

\section{Implementation Details}
\label{sec:compimplementation}

Recall the structure of an SIDH Yoo et al. signature, $\sigma$;

$$
\sigma = (\code{comm}, \code{ch}, \code{h}, \code{resp})
$$
where \code{comm}, \code{ch}, \code{h}, and \code{resp} are arrays containing $2\lambda$ elements each, with the exception of \code{comm}, which contains $4\lambda$ elements (2 for each iteration of the procedure).

\code{comm} is composed of by $\mathbb{F}_{p^2}$ elements, each denoting a curve (which acts as a commitment), in the following way:
$$
\code{comm} = [m_{0, 1}, m_{0, 2}, m_{1, 1}, m_{1, 2}, ... , m_{2\lambda, 1}, m_{2\lambda, 2}]
$$
\code{ch} is composed of by
$$
\code{ch} = []
$$
\code{h} is an array of hex numbers, each one the result of concatinating the output of two Keccak function calls.\footnote{Keccak is a cryptographic hash function from which the newly standardized SHA-3 is based.} 
$$
\code{h} = [\code{keccak(resp[0])}|\code{keccak(resp[1])}, ... , \code{keccak(resp[4}\lambda\code{ - 2])}|\code{keccak(resp[4}\lambda\code{ - 1])}]
$$

And so, the total size of an uncompressed signature is $size = 1 + 2 + 3 + 4$.


\subsection{Implementation Details}

\subsection{$\psi(S)$ Compression}

\noindent
\textit{Potential Tradeoffs}.

\section{Results}

Our technique can reduce the size of \sidh signature compression from \_\_\_ bits to \_\_\_ bits.

\subsection{Analysis}

\subsection{Potential Performance Improvements}

could use a non-constant implementation of double and add instead of montgomery's ladder? 

