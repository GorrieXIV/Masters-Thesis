\chapter{Compressing Signatures}
\label{sec:compress}

Our second contribution, also in the form of an addition to the \sidh signature extension, is a mechanism for compressing signatures. The following chapter will cover the compression technique used. This chapter, much like the last, will be split into three sections: a brief coverage of the employed compression technique, the details of our implementation and integration of this technique into \sidh, and finally an analysis of the results of this contribution.

In the first section of this chapter, we discuss the SIDH public key compression technique outlined in \cite{compwr}. We attempt to provide a sufficient overview of the technique while only covering in detail the components that are of significant relevance to our implementation. For those who seek to better understand the ins and outs of this technique should direct themselves to the original paper.  

The second Section covers in detail how we apply this public key compression to Yoo et al. signatures. We make use of the functions offered in \cite{pkcomp} which implement the methods of \cite{compwr} for public key compression. This code was first made available in the second installment of Microsoft's SIDH library.

Finally, we round off the Chapter with an analysis of the memory improvement offered by this technique. We contrast this spatial improvement with the computational cost of compressing points, and discuss the practicality of employing this technique. 

\section{SIDH Key Compression Background}

Recall from Section \ref{subsec:sidhkex} the structure of an SIDH public key, denoted $pk$;
$$
pk = (E, P, Q)
$$
Where $E$ is a supersingular elliptic curve and $P$ and $Q$ are elliptic curve points such that $P, Q \in E$. Recall that E can be represented logically by one $\mathbb{F}_{p}$ element which denotes $A$ from the following definition of $E$:
$$
E : y^2 = x^3 + Ax + B,
$$

$A$ sufficiently represents $E$ in this context because in \sidh we are concerned only with curves where $B$ = 0. 

$P$ and $Q$, on the other hand, can each be represented by their $x$-coordinate (two $\mathbb{F}_{p}$ elements) and a single bit determining the correct $y$-coordinate. Therefore, this approach can represent SIDH public keys with $~6\log p$ bits.

\subsection{Public Key Compression}

Azerderakhsh et al. showed in \cite{compwr} that the size of $pk$ can be further compressed to $4\log p$ bits. Consider the following.

Given $P \in E[\ell]$, $P$ can be represented by elements $\alpha, \beta \in \mathbb{Z}/\ell\mathbb{Z}$. These elements are computed as the coefficients of $P$ with respect to some fixed basis $\{R_1, R_2\}$ in the following manner: 
$$
P = \alpha R_1 + \beta R_2,
$$

Assuming $\alpha$ is invertible, we then have

$$
P = R_1 + \alpha^{-1}\beta R_2
$$

And so, as long as \alice and \bob can agree on a basis $\{R_1, R_2\}$ they can both sufficiently represent one anothers public keys with only\\

\noindent
\textit{Constructing the Basis}.\\

\noindent
\textit{Pohlig-Hellman}.\\

The work of \cite{pkcomp} further developed this approach to achieve public key sizes of $\frac{7}{2}\log p$. 



\subsection{Decompressing Public Keys}


\section{Implementation Details}
\label{sec:compimplementation}

Recall from \ref{sec:sigsbackground} the structure of a Yoo et al. signature, $\sigma$:
$$
\sigma = (com, ch, h, resp)
$$

\noindent
Where

\begin{itemize}
\item $com$ is a list of $2\lambda$ pairs of supersingular elliptic curves: $\{(E_{1,1}, E_{2,1}), (E_{1,2}, E_{2,2}), ..., (E_{1,2\lambda}, E_{2,2\lambda})\}$,
\item $ch$ is a list of $2\lambda$ randomly chosen bits,
\item $resp$ is a list where each element is either a single elliptic curve point or a pair of points, and
\item $h$ is a list of $2\lambda$ queries to a random oracle \textbf{G}, such that $h_{i} = \textbf{G(}resp_{i}\textbf{)}$
\end{itemize}

The representation of $\sigma$ in the C implementation offered by \cite{yoo} has a few noteworthy differences. Signatures in this setting are defined in the following way:
\begin{figure}[!h]
\begin{lstlisting}
struct Signature {
	unsigned char *Commitments1[NUM_ROUNDS];
	unsigned char *Commitments2[NUM_ROUNDS];
	unsigned char *HashResp;
	unsigned char *Randoms[NUM_ROUNDS];
	point_proj *psiS[NUM_ROUNDS];

	int compBit[NUM_ROUNDS];
	int compressed;
};
\end{lstlisting}
\caption{\pbinv}
\label{code:sigstruct}
\end{figure}

$$
\sigma = (\code{comm}, \code{ch}, \code{h}, \code{resp})
$$
where \code{ch}, \code{h}, and \code{resp} are arrays containing $2\lambda$ elements, and \code{comm} is an array containing $4\lambda$ elements. 

\code{comm} is composed of $4\lambda$ $\mathbb{F}_{p^2}$ elements, each denoting a curve (which acts as a commitment), in the following way:
$$
\code{comm} = [m_{0, 1}, m_{0, 2}, m_{1, 1}, m_{1, 2}, ... , m_{2\lambda, 1}, m_{2\lambda, 2}]
$$
\code{ch}, the array of challenge values, contains $2\lambda$ random integers, each of value $0$ or $1$. 
$$
\code{ch} = []
$$
\code{h} is an array of hex numbers, each one the result of concatinating the output of two Keccak function calls.\footnote{Keccak is a cryptographic hash function from which the newly standardized SHA-3 is based.} 
$$
\code{h} = [\code{keccak(resp[0])}|\code{keccak(resp[1])}, ... , \code{keccak(resp[4}\lambda\code{ - 2])}|\code{keccak(resp[4}\lambda\code{ - 1])}]
$$
The last component of $\sigma$ is \code{resp}, an array containing the responses to each challenge on a given commitment. 

And so, the total size of an uncompressed signature is $size = 1 + 2 + 3 + 4$.

\textit{Representing the Signature.} For every entry of \code{resp} there are two possibilities: 


\subsection{Implementation Details}

\subsection{$\psi(S)$ Compression}

\noindent
\textit{Constructing the Basis}

\subsection{Retrieving Correct $\psi(S)$ Values}

\noindent
\textit{Potential Tradeoffs}.

\section{Results}

Our technique can reduce the size of \sidh signature compression from \_\_\_ bits to \_\_\_ bits.

\subsection{Analysis}

\subsection{Potential Performance Improvements}

could use a non-constant implementation of double and add instead of montgomery's ladder? 

