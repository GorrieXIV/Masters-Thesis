\chapter{\sidh Functions}
\label{app:functions}

\section{$\mathbb{F}_p$ and $\mathbb{F}_{p^2}$ Functions}

\section{Isogeny and Point-wise Functions}

\subsection{\code{j\_inv}}

\begin{lstlisting}
void j_inv(const f2elm_t A, const f2elm_t C, f2elm_t jinv) {
	f2elm_t t0, t1;
	fp2sqr751_mont(A, jinv);                           // jinv = A^2        
	fp2sqr751_mont(C, t1);                             // t1 = C^2
	fp2add751(t1, t1, t0);                             // t0 = t1+t1
	fp2sub751(jinv, t0, t0);                           // t0 = jinv-t0
	fp2sub751(t0, t1, t0);                             // t0 = t0-t1
	fp2sub751(t0, t1, jinv);                           // jinv = t0-t1
	fp2sqr751_mont(t1, t1);                            // t1 = t1^2
	fp2mul751_mont(jinv, t1, jinv);                    // jinv = jinv*t1
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2sqr751_mont(t0, t1);                            // t1 = t0^2
	fp2mul751_mont(t0, t1, t0);                        // t0 = t0*t1
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2inv751_mont(jinv);                              // jinv = 1/jinv
	fp2mul751_mont(jinv, t0, jinv);                    // jinv = t0*jinv
}
\end{lstlisting}

\subsection{\code{j\_inv\_batch}}

\begin{lstlisting}
void j_inv_batch(f2elm_t A, f2elm_t C, f2elm_t jinv, invBatch* batch) {	
	f2elm_t t0, t1;
\end{lstlisting}
\vspace{-\baselineskip}
\begin{lstlisting}[backgroundcolor=\color{light-green}, firstnumber=3]
	int tempCnt;
\end{lstlisting}
\vspace{-\baselineskip}
\begin{lstlisting}[firstnumber=4]
	fp2sqr751_mont(A, jinv);                           // jinv = A^2        
	fp2sqr751_mont(C, t1);                             // t1 = C^2
	fp2add751(t1, t1, t0);                             // t0 = t1+t1
	fp2sub751(jinv, t0, t0);                           // t0 = jinv-t0
	fp2sub751(t0, t1, t0);                             // t0 = t0-t1
	fp2sub751(t0, t1, jinv);                           // jinv = t0-t1
	fp2sqr751_mont(t1, t1);                            // t1 = t1^2
	fp2mul751_mont(jinv, t1, jinv);                    // jinv = jinv*t1
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2sqr751_mont(t0, t1);                            // t1 = t0^2
	fp2mul751_mont(t0, t1, t0);                        // t0 = t0*t1
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
	fp2add751(t0, t0, t0);                             // t0 = t0+t0
\end{lstlisting}
\vspace{-\baselineskip}
\begin{lstlisting}[backgroundcolor=\color{light-green}, firstnumber=19]
	pthread_mutex_lock(&batch->arrayLock);
	fp2copy751(jinv, batch->invArray[batch->cntr]);
	tempCnt = batch->cntr;
	batch->cntr++; 
	pthread_mutex_unlock(&batch->arrayLock);	

	int i;
	if (tempCnt+1 == batch->batchSize) {
		partial_batched_inv(batch->invArray, batch->invDest, batch->batchSize);
		for (i = 0; i < batch->batchSize - 1; i++) {
			sem_post(&batch->sign_sem);			
		}
	} else {
		sem_wait(&batch->sign_sem);
	}
	fp2copy751(batch->invDest[tempCnt], jinv);
	batch->cntr = 0;
\end{lstlisting}%
\vspace{-0.75\baselineskip}
\begin{lstlisting}[firstnumber=36]
	fp2mul751_mont(jinv, t0, jinv);                    // jinv = t0*jinv
}
\end{lstlisting}

\subsection{\code{inv\_4\_way}}

\begin{lstlisting}
void inv_4_way(f2elm_t z1, f2elm_t z2, f2elm_t z3, f2elm_t z4) {
  	f2elm_t t0, t1, t2;
	int tempCnt;

    fp2mul751_mont(z1, z2, t0);                      // t0 = z1*z2
    fp2mul751_mont(z3, z4, t1);                      // t1 = z3*z4
    fp2mul751_mont(t0, t1, t2);                      // t2 = z1*z2*z3*z4
    fp2inv751_mont(t2);                              // t2 = 1/(z1*z2*z3*z4)
    fp2mul751_mont(t0, t2, t0);                      // t0 = 1/(z3*z4) 
    fp2mul751_mont(t1, t2, t1);                      // t1 = 1/(z1*z2) 
    fp2mul751_mont(t0, z3, t2);                      // t2 = 1/z4
    fp2mul751_mont(t0, z4, z3);                      // z3 = 1/z3
    fp2copy751(t2, z4);                              // z4 = 1/z4
    fp2mul751_mont(z1, t1, t2);                      // t2 = 1/z2
    fp2mul751_mont(z2, t1, z1);                      // z1 = 1/z1
    fp2copy751(t2, z2);                              // z2 = 1/z2
}
\end{lstlisting}

\subsection{\code{inv\_4\_way\_batch}}

\begin{lstlisting}
void inv_4_way_batch(f2elm_t z1, f2elm_t z2, f2elm_t z3, f2elm_t z4, invBatch* batch) {
  	f2elm_t t0, t1, t2;
	int tempCnt;

    fp2mul751_mont(z1, z2, t0);                      // t0 = z1*z2
    fp2mul751_mont(z3, z4, t1);                      // t1 = z3*z4
    fp2mul751_mont(t0, t1, t2);                      // t2 = z1*z2*z3*z4
\end{lstlisting}
\vspace{-\baselineskip}
\begin{lstlisting}[backgroundcolor = \color{light-green}, firstnumber=8]
	pthread_mutex_lock(&batch->arrayLock);
	fp2copy751(t2, batch->invArray[batch->cntr]);
	tempCnt = batch->cntr;
	batch->cntr++; 
	pthread_mutex_unlock(&batch->arrayLock);
	int i;		
	if (tempCnt+1 == batch->batchSize) {
		partial_batched_inv(batch->invArray, batch->invDest, batch->batchSize);
		for (i = 0; i < batch->batchSize; i++) {
			sem_post(&batch->sign_sem);			
		}
	} else {
		sem_wait(&batch->sign_sem);
	}
	fp2copy751(batch->invDest[tempCnt], t2);
	batch->cntr = 0;
\end{lstlisting}
\vspace{-\baselineskip}
\begin{lstlisting}[firstnumber=24]
    fp2mul751_mont(t0, t2, t0);                      // t0 = 1/(z3*z4) 
    fp2mul751_mont(t1, t2, t1);                      // t1 = 1/(z1*z2) 
    fp2mul751_mont(t0, z3, t2);                      // t2 = 1/z4
    fp2mul751_mont(t0, z4, z3);                      // z3 = 1/z3
    fp2copy751(t2, z4);                              // z4 = 1/z4
    fp2mul751_mont(z1, t1, t2);                      // t2 = 1/z2
    fp2mul751_mont(z2, t1, z1);                      // z1 = 1/z1
    fp2copy751(t2, z2);                              // z2 = 1/z2
}
\end{lstlisting}

\section{Key Exchange Functions}

\section{Signature Layer Functions}
