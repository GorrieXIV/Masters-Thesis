\chapter{Introduction}

The past 30 years have brought with them astonishing developments in the field of quantum computing.

Quantum computers have been shown to possess computing power beyond that of our classically binary architectures. Through the continually developing articulation of quantum algorithms, we have witnessed the discovery of algorithms capable of efficiently solving problems with no previously known subexponential solution. This class of problems resides in the complexity class known as BQP, or \textit{bounded-error quantum polynomial-time}. Included in this class of problems is the hidden subgroup problem. It is this problem which lies at the heart of nearly all asymmetric cryptosystems in common use. Thus, the potential of implementing a quantum computer capable of carrying out such an algorithm poses a serious threat to the backbone of modern Internet security.  

And so, as physicists and engineers race towards error-free and energy efficient implementations of quantum computers, we steadfastly approach a New Age for the art and science of Cryptography. This ``post-quantum" cryptography.\\

\noindent
\textit{Isogeny Based Cryptography}. Over the course of the past decade, elliptic curve cryptography (ECC) has proven itself a mainstay in the wide world of applied cryptology. While isogeny based cryptography and ECC are constructed from the same underlying field of mathematics, they differ in their fundamental presuppositions.


\section{Motivation}
\label{sec:motivation}



The aim of this dissertation is to improve the efficiency of a particular isogeny based scheme. We hope to showcase that, through intelligent implementation, isogeny based protocols still have a lot of improvement potential in terms of run-time and storage performance. 

More specifically, we will be investigating the C implementation of the Yoo et al. isogeny based signature scheme. 

\noindent
\textit{Lattice-based Cryptography}.\\

\noindent
\textit{Hash-based Cryptography}.\\

\noindent
\textit{Multivariate Cryptography}.\\

\noindent
\textit{Code-based Cryptography}.\\


It's clear that isogeny based schemes have a long way to go in terms of temporal performance before they can hold their own against protocols such as \_\_\_ or even the post-quantum \_\_\_. The exceptionally small key sizes of SIDH and other isogeny-based schemes, however, are an advantage worth noting. 


\subsection{Performance History of Isogeny Based Cryptosystems}

Post-quantum cryptography has been the subject of rigorous research for over a decade now. 

Progress in the subfield of isogeny-based cryptography has been made slowly yet surely in this time, with the majority of its contributions arriving from one of two sources: the Institute for Quantum Computing (IQC) at Waterloo University, and the Microsoft Research team in \_\_\_. 

Most notably, this research is built upon an isogeny-based signature scheme published by Yoo et al. 

\subsection{Post-Quantum and Classical Performance Comparisons}

We will now provide a rough survey of the many post-quantum schemes and contrast their performance (both temporally in terms of exeuction time, and spatially in terms of key and signature sizes) with popular non-quantum-safe systems.\\

\noindent
\textit{Key Exchange Run-times}.

All numbers are taken at a 128-bit post-quantum security level.

\begin{itemize}
\item NTRU -- Lattice-based key-exchange
\item NewHope -- Lattice-based key-exchange (Ring variant)
\item McEliece -- Code-based key-exchange
\item ECDH -- elliptic curve classical key-exchange
\end{itemize}

\noindent
\textit{Signature Scheme Run-times}.

\begin{itemize}
\item Sphincs -- Hash-based signature
\item Rainbow -- Multivariate-based signature
\item qTESLA -- Lattice-based signature (Ring variant)
\item Picnic -- Hash-based zero-knowledge proof signature
\item DSA -- Classical signature scheme
\item ECDSA -- Classical elliptic curve signature scheme
\end{itemize}

\noindent
\texit{Signature Sizes}.

\begin{itemize}
\item Sphincs -- Hash-based signature -- 16976 byte signatures
\item Rainbow -- Multivariate-based signature -- 64 - 104 byte signatures
\item qTESLA -- Lattice-based signature (Ring variant) -- 3104 byte signatures
\item Picnic -- Hash-based zero-knowledge proof signature -- 34004 - 53933 byte signatures
\item DSA -- Classical signature scheme
\item ECDSA -- Classical elliptic curve signature scheme
\end{itemize}

\noindent
\texit{Public Key Sizes}.

\begin{itemize}
\item Sphincs -- Hash-based signature -- 32 byte public keys
\item Rainbow -- Multivariate-based signature -- 152097 - 192241 byte public key
\item qTESLA -- Lattice-based signature (Ring variant) -- 4128 byte public keys
\item Picnic -- Hash-based zero-knowledge proof signature -- 33 byte public keys
\item DSA -- Classical signature scheme
\item ECDSA -- Classical elliptic curve signature scheme
\end{itemize}

\section{Contributions}

We offer two main contributions to the Yoo et al. signature scheme implementation. Both of these contributions are designed with the intent of improving the performance of the Yoo et al. signature scheme: the first offers an improvement in the run-time of the signature scheme and the second 

All of these contributions can be found and tested at https://github.com/GorrieXIV/SIDH2.0-SignatureExtension .

\subsection{Protocol Performance}

Our first contribution involves the implementation of a procedure which batches together many of the same operations to offer a drastic reduction in runtime. This scheme leverages the already parallel nature of the protocol by waiting for expensive operations that are due to occur accross all threads, suspending the threads and performing the batching procedure, and then resuming the run.


\subsection{Signature Size}



Additionally, because the compression algorithm in question is itself tenable two contributions can be \\

\section{Structure}


\subsection{Layout}

This dissertation is divided into 5 Chapters. This Chapter and the one that follows contain the relevent preliminary information for understanding the contributions of the thesis. The two following Chapters thereafter outline in detail the two contributions of this dissertation. The 5$^{\text{th}}$ and final Chapter concludes the dissertation while offering any final remarks and suggestions for continued research.

Chapter 2 covers the relevant mathematics background and is far and away the longest Chapter. Within this Chapter we also cover the portions of the SIDH C library that are utilized and/or modified in our implementations. It is worth noting that thorough and complete coverage of this chapter is not necessary for a satisfactory understanding of our contributions, nor is it necessary for understanding the conclusions we come to make about the usefulness of our techniques, and of the studied isogeny-based signature scheme at large.

If, however, the reader desires to pursue isogeny-based cryptosystems in a research setting, then Chapter 2 will (hopefully) prove to be an effective and digestible surface-level introduction to this subfield.  

Chapters 3 \& 4 are rather similar in structure. Both begin with an introduction of their contribution's components - doing so in a general setting. Following this, the implementation specifics of the Chapters contribution are layed out. For these Sections, we attempt to convey the implementation details with a level of granularity we find easily accessible, while also providing enough information such that if the reader were to dive into the codebase they could do so comfortably. The final Sections of Chapters 4 \& 5 include the implementation results, benchmarks, and analysis. The main structural difference between these two Chapters is that Chapter 4 requires additional background. We found it more appropriate to include this material here, in the introduction to Chapter 4, rather than in Chapter 2.

\subsection{Notation \& Style}

We will now take some time for formalizing the variety of notation and formatting  used in this dissertation.\\

\noindent
\textit{General Conventions.} Throughout the text, \textit{italics} are used as a means of applying emphasis. This is done frequently to draw attention to newly introduced terms or to suggest the cadence of a sentence. Additionally, italics are employed to add further structure to (sub)sections; a non-indented paragraph following a horizontal space will often begin with an italicized term or concept. These italicized sentences denote the beginning of a new discussion topic.\\

\noindent
\textit{Functions \& Procedures}. Throughout the dissertation, general functions and procedures are denoted by the use of a \textbf{bold font face}. This is true for procedures introduced both formally and informally. Functions that are defined within the \sidh C codebase (either by us or others), however, are denoted by the use of a \code{monospace font}. This monospace notation is also sometimes used to denote routines or subroutines composed of by a sequence of functions or a portion of code. 

When referring to a function in any general sense, we will write only its name using the aforemention convention. By contrast, when we refer to the result of a function executed over input $x_{1}, ..., x_{n}$, we append on the function identifier the set of parameters enclosed in parathesis (e.g. \textbf{GenericFunction($x_{1}, ..., x_{n}$) or \code{GenericFunction($x_{1}, ..., x_{n}$)}}. 

It is also worth noting that we frequently refer to these abstract, bold-identified functions as \textit{procedures}, whereas we try to reserve use of the term \textit{function} for C-defined \sidh functions. When giving precise definitions of procedures, we opt for a pseudocode/algorithmic approach. For functions, on the otherhand, we enclose our definitions in an environment with a light-gray background. Consider the following: \\

\begin{algorithm}
\caption{-- \textbf{ProcedureExample($\{a_0, a_1, ... , a_b\}$, $c$)}}\label{alg:procedureexample}
\begin{algorithmic}[1]
\If{$c \leq b$}
	\State \Return $a_c$
\Else
	\State \Return $-1$
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{figure}[!h]
\label{code:pbinv}
\begin{lstlisting}
void function_example (int* a, int b, int c) {
	if (c <= b) {
		return a[c];
	} else {
		return -1;
	}
}
\end{lstlisting}
\caption{Function example.}
\end{figure}

\noindent
\textit{Cryptography Conventions}. Cryptographic protocols, as per the usual convention, are written and defined in terms of tuples of algorithms. In denoting general protocols, we frequently use a capital Pi ($\Pi$) subscripted with some informative title.

\noindent
\textit{Math Conventions}. In denoting isogonies (and other functions between elliptic curves) we will opt to use upper-case greek letters. Elliptic curves discussed in a general setting are refered to, when possible, as $E$; if a more unique identifier is necessary, $E$ with a unique subscript is used. For example, $E_{Alice}$ might refer to a curve created by Alice.  


