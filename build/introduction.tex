\chapter{Introduction}

The past 30 years have brought with them astonishing developments in the field of quantum computing. With these developments, quantum computers have been shown to possess computing power beyond that of our classical, binary architectures. Through the continually developing articulation of quantum algorithms, we have witnessed the discovery of algorithms capable of efficiently solving problems which had no prior known subexponential solution. 

introduce crypto and assymetric crypto

These problems with newly discovered subexponential solutions reside in the complexity class known as BQP, or ``bounded-error quantum polynomial-time". Included in this class of problems is the \textit{hidden subgroup problem}. It is also the case that the prior-assumed difficulty of this particular problem is crucial to the security of nearly all asymmetric cryptosystems in common use. Thus, the implementation of a sufficiently large quantum computer would be a catastrophic threat to the backbone of modern Internet security.  

And so, as physicists and engineers race towards error-free and energy efficient implementations of quantum computers, we steadfastly approach a New Age for the art and science of Cryptography. The looming threat of large-scale quantum computing has driven the field of ``post-quantum" cryptography; the aspiration of which is to develop efficient and secure cryptographic algorithms that are resistant to quantum cryptanalysis. Post-quantum cryptosystems are those which avoid any underlying assumptions on the difficulty of the hidden subgroup problem.\\

\section{Motivation}
\label{sec:motivation}

The following Section will discuss or make reference to cryptographic concepts that may be foreign to the reader. Section  \ref{sec:crypto} provides detailed definitions for some of these concepts, and may prove helpful in illuminating some of the coming discussion.\\

There are several subfields that currently occupy the research space of post-quantum cryptography. These subfields are each predicated on their own underlying mathematical problems, and more importantly, assumptions on the difficulty of those problems. The following make up some of the most popular subfields of post-quantum cryptography: 
\begin{itemize}
\item \textit{Lattice-based Cryptography}, based on problems such as LWE and Ring-LWE, 
\item \textit{Hash-based Cryptography}, building signatures from cryptographic hash functions, 
\item \textit{Multivariate Cryptography}, systems designed around multivariate polynomials, 
\item \textit{Code-based Cryptography}, based on the difficulty of decoding linear codes.
\end{itemize}

For this dissertation, however, we will focus on a younger subfield of post-quantum cryptography, namely, isogeny-based cryptography.\\

\noindent
\textit{Isogeny-based Cryptography}. Over the course of the past decade, elliptic curve cryptography (ECC) has proven itself indisposable in the world of applied cryptology. While isogeny-based cryptography and ECC are built up from elliptic curve mathematics, they differ in their fundamental presuppositions.

Isogeny-based systems have not yet stood the test of time in terms of cryptanalytic scrutiny. Because of this, some may be hesitant to concede the purported security of these systems. Additionally, they are often outperformed by other post-quantum alternatives (which we will investigate more closely in a moment). They do, however, appear to have some advantages. 

And so, the aim of this dissertation is to improve the efficiency of a particular isogeny-based scheme. We hope to showcase that, through intelligent implementation, isogeny-based protocols still have a lot of improvement potential in terms of run-time and storage performance.

More specifically, for this dissertation we are primarily focused on the performance of an isogeny-based ``proof of knowledge" style signature scheme, outlined in great detail by Youngo Yoo et al. in \cite{yoo}, which we will henceforth refer to as the ``Yoo et al. signature scheme".

\subsection{Post-Quantum and Classical Performance Comparisons}

We will now provide a rough survey of several post-quantum cryptosystems so as to compare their performance (both temporally in terms of exeuction time, and spatially in terms of key and signature sizes) with popular non-quantum-safe systems.\\

We gathered runtime measurements of the Yoo et al. signature scheme from \cite{yoosigcode}, runtimes for other post-quantum schemes from \cite{libpqcrypto} and \cite{openqs}, and runtimes of classical protocols ECDH, RSA, and ECDSA from the standard OpenSSL distribution. We've compiled the results into Figures \ref{fig:kextimes}, \ref{fig:sigtimes}, and \ref{fig:sigtimes}. In Figures \ref{fig:sigtimes} and \ref{fig:sigsizes}, ``SIDH" is used to represent the Yoo et al. signature scheme, which (as we will see in the coming Chapter) is largely based on the SIDH system.

\begin{figure}[!h]
\label{fig:kextimes}
\begin{center}
\begin{tabular}{l | b }
\hline
\mc{1}{} & \mc{1}{Cycles}\\
\hline
\rowcolor{Gray}
SIDH & c \\
NTRU (LWE) & c \\
NewHope (Ring-LWE) & c \\
McEliece (Code-based) & c \\
\rowcolor{light-red}
ECDH & c \\
\hline
\end{tabular}
\caption{Comparison of post-quantum and classical key-exchange runtimes}
\end{center}
\end{figure}

\begin{figure}[!h]
\label{fig:sigtimes}
\begin{center}
\begin{tabular}{l | b | b | b }
\hline
\mc{1}{}  & \mc{1}{Key Gen} & \mc{1}{Sign} & \mc{1}{Verify}\\
\hline
\rowcolor{Gray}
SIDH & a & b & c \\
Sphincs (Hash-based) & a & b & c \\
Rainbow (Multivariate-based) & a & b & c \\
qTESLA (Ring-LWE) & 1059388 & 460592 & 66491 \\
Picnic (Hash-based) & 13272 & 9560749 & 6701701 \\
\rowcolor{light-red}
RSA & a & b & c \\
\rowcolor{light-red}
ECDSA & a & b & c \\
\hline
\end{tabular}
\caption{}
\end{center}
\end{figure}

\begin{figure}[!h]
\label{fig:sigsizes}
\begin{center}
\begin{tabular}{l | b | b | b }
\hline
\mc{1}{}  & \mc{1}{Public Key} & \mc{1}{Private Key} & \mc{1}{Signature}\\
\hline
\rowcolor{Gray}
SIDH & 768 & b & 141,312 \\
Sphincs (Hash-based) & 32 & 64 & 8,080 - 16,976 \\
Rainbow (Multivariate-based) & 152,097 - 192,241 & 100,209 - 114,308 & 64 - 104 \\
qTESLA (Ring-LWE) & 4,128 & 2,112 & 3,104 \\
Picnic (Hash-based) & 33 & 49 & 34,004 - 53,933 \\
\rowcolor{light-red}
RSA & 384 & b & 384 \\
\rowcolor{light-red}
ECDSA & 32 & b & 32 \\
\hline
\end{tabular}
\caption{Signature and key sizes for various post-quantum and classical protocols}
\end{center}
\end{figure}

All of the measurements in these figures reflect implementations which offer 128 bit post-quantum security, with the exception of classical protocols ECDH, RSA, and ECDSA, where numbers are taken at the 128-bit \textit{classical} security level.

The runtime benchmarks found in Figure \ref{fig:kextimes} and Figure \ref{fig:sigtimes} are all given in terms of CPU cycles, and as such are more architecture independent than timestamp-based measurements. The measurements for signature and key sizes in Figure \ref{fig:sigsizes} are given in terms of bytes. 

Reflecting on Figures \ref{fig:kextimes} \ref{fig:sigtimes}, < talk about comparison results >.

As for Figure \ref{fig:sigsizes}, < talk about size comparison results >.

\section{Contributions}

We offer two main contributions to the Yoo et al. signature scheme implementation. Both of these contributions, as previously mentioned, are designed with the intent of improving the performance of said protocol: the first offers an improvement in the run-time of the signature scheme and the second offers reduced signature sizes for the scheme.\\

\noindent
All of these contributions can be found and tested at \url{https://github.com/GorrieXIV/SIDH2.0-SignatureExtension}.

\subsection{Operation Batching}

Our first contribution involves the implementation of a procedure that batches together many occurances of the same low level operation, drastically reducing the total count of a particularly expensive operation. We provide C code which incorporates this batching procedure into the Yoo et al. signature scheme code.

In the Section detailing this contribution, we offer extensive measurements of the performance increases offered by the inclusion of the batching procedure. We include also a discussion of other possible use-cases for operation batching in isogeny-based schemes, not covered by our implementation.

We conclude that the inclusion of our batching technique in the Yoo et al. signature scheme is both secure and offers noteworthy performance improvements in signature signing and verification routines.

\subsection{Signature Compression}

The second contribution we offer is another addendum to the SIDH/Yoo signature library, this time offering a mechanism to  compress signature sizes.  We embed a particular compression algorithm into the Yoo et al. signature protocol -- the compression algorithm in question (contrived by Costello et al. and outlined in \cite{pkcomp}) is intended for compression of SIDH public keys. We have adopted this method and applied it to specific portions of the Yoo et al. signatures, yielding significantly smaller signatures at the cost of extra computation.

This approach to signature compression is mentioned in \cite{yoo}, but not implemented. We detail our implementation in Section \ref{sec:compress}, and analyse both the decrease in signature size and the computational cost of performing comrpession. 

\section{Structure}

With the remaining Section of this introductory Chapter, we will disambiguate some of the structuring and notation used in this dissertation.

\subsection{Layout}

This dissertation is divided into 5 Chapters. This Chapter and the one that follows contain the relevent preliminary information for understanding the contributions of the thesis. The two following Chapters thereafter outline in detail the two contributions of our work. The 5$^{\text{th}}$ and final Chapter concludes the dissertation while offering any final remarks and suggestions for continued research.

Chapter 2, as mentioned, covers the relevant mathematical background and is far and away the longest Chapter. Within this Chapter we also cover the portions of the SIDH C library that are utilized and/or modified in our implementations. It is worth noting that thorough and complete coverage of this chapter is not necessary for a satisfactory understanding of our contributions, nor is it necessary for understanding the conclusions we come to make about the usefulness of our techniques, and of the studied isogeny-based signature scheme at large.

If, however, the reader desires to pursue isogeny-based cryptosystems in a research setting, then Chapter 2 will (hopefully) prove to be an effective and digestible surface-level introduction to this subfield.  

Chapters 3 \& 4 are rather similar in structure. Both begin with an introduction of their contribution's components - doing so in a general setting. Following this, the implementation specifics of the Chapters contribution are layed out. For these Sections, we attempt to convey the implementation details with a level of granularity we find easily accessible, while also providing enough information such that if the reader were to dive into the codebase they could do so comfortably. The final Sections of Chapters 4 \& 5 include the implementation results, benchmarks, and analysis. The main structural difference between these two Chapters is that Chapter 4 requires additional background. We found it more appropriate to include this material here, in the introduction to Chapter 4, rather than in Chapter 2.

The 5th Chapter closes out the dissertation with a summary of our progress and measurements. We then spend some time discussing possible avenues for future work. Following this chapter is Appendix A, which details C code for some of the SIDH C library functions which are particularly relevant to our work.

\subsection{Notation \& Style}

We will now take some time to formalize the variety of notation and formatting used in this dissertation.\\

\noindent
\textit{Italics.} Throughout the text, \textit{italics} are used as a means of applying emphasis. This is done frequently to draw attention to newly introduced terms or to suggest the cadence of a sentence. Additionally, italics are employed to add further structure to (sub)sections; a non-indented paragraph following a horizontal space will often begin with an italicized term or concept. These italicized sentences denote the beginning of a new discussion topic.\\

\noindent
\textit{Functions \& Procedures}. Throughout the dissertation, general functions and procedures are denoted by the use of a \textbf{bold font face}. This is true for procedures introduced both formally and informally. Functions that are defined within the SIDH C codebase (either by us or others), however, are denoted by the use of a \code{monospace font}. This monospace notation is also sometimes used to denote routines or subroutines composed of by a sequence of functions or a portion of code. 

When referring to a function in any general sense, we will write only its name using the aforemention convention. By contrast, when we refer to the result of a function executed over input $x_{1}, ..., x_{n}$, we append on the function identifier the set of parameters enclosed in parathesis (e.g. \textbf{GenericFunction($x_{1}, ..., x_{n}$) or \code{GenericFunction($x_{1}, ..., x_{n}$)}}. 

It is also worth noting that we frequently refer to these abstract, bold-identified functions as \textit{procedures}, whereas we try to reserve use of the term \textit{function} for C-defined functions. When giving precise definitions of procedures, we opt for a pseudocode/algorithmic approach. For functions, on the otherhand, we enclose our definitions in an environment with a light-gray background. Below we illustrate these two different approaches:\\

\begin{algorithm}
\caption{-- \textbf{ProcedureExample($\{a_0, a_1, ... , a_b\}$, $c$)}}\label{alg:procedureexample}
\begin{algorithmic}[1]
\If{$c \leq b$}
	\State \Return $a_c$
\Else
	\State \Return $-1$
\EndIf
\end{algorithmic}
\end{algorithm}

\label{code:pbinv}
\begin{lstlisting}
void function_example (int* a, int b, int c) {
	if (c <= b) {
		return a[c];
	} else {
		return -1;
	}
}
\end{lstlisting}

\noindent
\textit{Cryptography Conventions}. Cryptographic protocols, as per the usual convention, are written and defined in terms of tuples of algorithms. In denoting general protocols, we frequently use a capital Pi ($\Pi$) subscripted with some informative title. Following this format, $\Pi_{\text{sig}}$.\textbf{KeyGen} might represent the key generation algorithm found in some signature protocol. If the context is clear, we may refer to an algorith/procedure such as this simply by its name (e.g. \textbf{KeyGen}), dropping the leading protocol identifier.\\

\noindent
\textit{Math Conventions}. In denoting isogonies (and other functions between elliptic curves) we will opt to use upper-case greek letters. Elliptic curves discussed in a general setting are refered to, when possible, as $E$; if a more unique identifier is necessary, $E$ with a unique subscript is used. For example, $E_{Alice}$ might refer to a curve created by Alice.  


