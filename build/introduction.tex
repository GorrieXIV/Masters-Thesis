\chapter{Introduction}

The past 30 years have brought with them astonishing developments in the field of quantum computing.

Quantum computers have been shown to possess computing power beyond that of our current binary, Von-Neumann, classical architectures. Since the articulation of quantum algorithms, we have witnessed the  algorithms capable of efficiently solving problems that, up until the discovery of such algorithms, had no subexponential solution. This class of problems resides in the complexity class known as BQP, or \textit{bounded-error quantum polynomial-time}. Included in this class of problems is the hidden subgroup problem. It is this problem which lies at the heart of nearly all asymmetric cryptosystems in common use. Efficiently solve the hidden subgroup problem and you have efficiently compramised the backbone of Internet security.  

And so, as physicists and engineers race towards error-free and energy efficient implementations of quantum computers, we steadfastly approach a New Age for the art and science of Cryptography. 

Over the course of the past decade, elliptic curve cryptography (ECC) has proven itself a mainstay in the wide world of applied cryptology. While isogeny based cryptography does build itself up from the same underlying field of mathematics as ECC, it simultaneously draws from a slightly more complicated space of algebraic notions. Much of this chapter will be dedicated to illuminating these notions in a manner that should be digestable for those without serious background in algebraic geometry, or abstract algebra in general.


\section{Motivation}

Our aim is to improve the efficiency (thus improving the practicality) of isogeny based schemes. More specifically, we will be investigating the C implementation of the Yoo et al. isogeny based signature scheme. 

We can provide a quickly sketched survey of the many post-quantum schemes and contrast their performance (both temporally in terms of exeuction time, and spatially in terms of key and signature sizes) with popular non-quantum-safe systems.

It's clear that isogeny based schemes have a long way to go in terms of temporal performance before they can hold their own against protocols such as \_\_\_ or even the post-quantum \_\_\_. The exceptionally small key sizes of SIDH and other isogeny-based schemes, however, are an advantage worth noting. 

\subsection{Related Works}

Post-quantum cryptography has been the subject of rigorous and bountiful research for over a decade now. 

Progress in the subfield of isogeny-based cryptography has been made slowly yet surely in this time, with the majority of its contributions arriving from one of two sources: the Institute for Quantum Computing (IQC) at Waterloo University, and the Microsoft Research team in \_\_\_. 

Most notably, this research is built upon an isogeny-based signature scheme published by Yoo et al. 

\section{Contributions}

Our explicit contributions to the implementation of this protocol are twofold. Our first contribution involves the implementation of a procedure for batching . This scheme leverages the already parallel nature of the protocol, and.

Additionally, because the compression algorithm in question is itself tenable two contributions can be \\

All of these contributions can be found (and put to test) at https://github.com/GorrieXIV/SIDH2.0-SignatureExtension .

\subsection{Protocol Performance}

\subsection{Signature Size}


\section{Structure}


\subsection{Layout}

This dissertation is divided into 5 Chapters. This Chapter and the one that follows contain the relevent preliminary information for understanding the contributions of the thesis. The two following Chapters thereafter outline in detail the two contributions of this dissertation. The 5$^{\text{th}}$ and final Chapter concludes the dissertation while offering any final remarks and suggestions for continued research.

Chapter 2 covers the relevant mathematics background and is far and away the longest Chapter. Within this Chapter we also cover the portions of the SIDH C library that are utilized and/or modified in our implementations. It is worth noting that thorough and complete coverage of this chapter is not necessary for a satisfactory understanding of our contributions, nor is it necessary for understanding the conclusions we come to make about the usefulness of our techniques, and of the studied isogeny-based signature scheme at large.

If, however, the reader desires to pursue isogeny-based cryptosystems in a research setting, then Chapter 2 will (hopefully) prove to be an effective and digestible surface-level introduction to this subfield.  

Chapters 3 \& 4 are rather similar in structure. Both begin with an introduction of their contribution's components - doing so in a general setting. Following this, the implementation specifics of the Chapters contribution are layed out. For these Sections, we attempt to convey the implementation details with a level of granularity we find easily accessible, while also providing enough information such that if the reader were to dive into the codebase they could do so comfortably. The final Sections of Chapters 4 \& 5 include the implementation results, benchmarks, and analysis. The main structural difference between these two Chapters is that Chapter 4 requires additional background. We found it more appropriate to include this material here, in the introduction to Chapter 4, rather than in Chapter 2.

\subsection{Notation \& Style}

It is worth to take some time now formalizing the plethora of different notation used\\

One technique employed throughout this dissertation is the use of non-indented paragraphs which follow horizontal spaces. 

\noindent
\textit{General Conventions.} Throughout the text, \textit{italics} are used as a means of applying emphasis. This is done frequently to draw attention to newly introduced terms, sometimes in a literary-rhetoric sense, , and othertimes to 

To denote high-level procedures, we write their titls in \textbf{bold}. Procedures intended for machine execution are titled with \code{monospace} font - and we use the same notation for C modules, functions, and variable name.\\

\noindent
\textit{Functions \& Procedures}. Throughout the dissertation, general functions and procedures are denoted by the use of a \textbf{bold font face}. This is true for procedures introduced both formally and informally. Functions that are defined within the \sidh C codebase (either by us or others), however, are denoted by the use of a \code{monospace font}. This monospace notation is also sometimes used to denote routines or subroutines composed of by a sequence of functions or a portion of code. 

When referring to a function in any general sense, we will write only its name using the aforemention convention. By contrast, when we refer to the result of a function executed over input $x_{1}, ..., x_{n}$, we append on the function identifier the set of parameters enclosed in parathesis (e.g. \textbf{GenericFunction($x_{1}, ..., x_{n}$) or \code{GenericFunction($x_{1}, ..., x_{n}$)}}. 

It is also worth noting that we frequently refer to these abstract, bold-identified functions as \textit{procedures}, whereas we try to reserve use of the term \textit{function} for C-defined \sidh functions. When giving precise definitions of procedures, we opt for a pseudocode/algorithmic approach. For functions, on the otherhand, we enclose our definitions in an environment with a light-gray background. Consider the following: \\

\begin{algorithm}
\caption{-- \textbf{ProcedureExample(\textbf{P}$_{\Pi}$)}}\label{alg:unruhconst}
\begin{algorithmic}[1]
\If{$User$ = $\alice$}
	\State Pick a random point $S$ of order $\laea$
\EndIf
\If{$User$ = $\bob$}
	\State Pick a random point $S$ of order $\lbeb$
\EndIf
\State Compute the isogeny $\phi: E \rightarrow E/\langle S \rangle$
\State $pk \gets (E/\langle S \rangle, \phi(P_{User}), \phi(Q_{User}))$
\State $sk \gets S$
\State \Return ($sk$, $pk$)
\end{algorithmic}
\end{algorithm}

\begin{figure}[!h]
\label{code:pbinv}
\begin{lstlisting}
void function_example (const f2elm_t* vec, f2elm_t* dest, const int n) {
	felm_t t0[n];     //a portion of vec elements
	felm_t t1[n];     //b portion of vec elements
	felm_t den[n];    //denominator of vec elements
	felm_t a[n];

	for (int i = 0; i < n; i++) {
		fpsqr751_mont((vec[i])[0], t0[i]);
		fpsqr751_mont((vec[i])[1], t1[i]);
		fpadd751(t0[i], t1[i], den[i]);
	}	
}
\end{lstlisting}
\caption{Function example.}
\end{figure}

\noindent
\textit{Math Conventions}. To donate isogonies (and other functions between elliptic curves) we will opt to use upper-case greek letters. Elliptic curves discussed in a general setting are refered to, when possible, as $E$; if a more unique identifier is necessary, $E$ with a unique subscript is used. For example, $E_{Alice}$ might refer to a curve created by Alice.  
