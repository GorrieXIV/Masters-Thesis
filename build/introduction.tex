\chapter{Introduction}

The past 30 years have brought with them astonishing developments in the field of quantum computing. With these developments, quantum computers have been shown to possess computing power beyond that of our classical, binary architectures. Through the continually developing articulation of quantum algorithms, we have witnessed the discovery of algorithms capable of efficiently solving problems which had no prior known subexponential solution. 

These problems with newly discovered subexponential solutions reside in the complexity class known as BQP, or ``bounded-error quantum polynomial-time". Included in this class of problems is what is known as the \textit{hidden subgroup problem}. It is also the case that the difficulty of this particular problem is crucial to the security of nearly all asymmetric cryptosystems in common use. Thus, the implementation of a sufficiently large quantum computer would be a catastrophic threat to the backbone of modern Internet security.  

And so, as physicists and engineers race towards error-free and energy efficient implementations of quantum computers, we steadfastly approach a New Age for the art and science of Cryptography. The looming threat of large-scale quantum computing has driven the field of ``post-quantum" cryptography; the aspiration of which is to develop efficient and secure cryptographic algorithms that are resistant to quantum cryptanalysis. Post-quantum cryptosystems are those which avoid any assumptions of the difficulty of the hidden subgroup problem.\\

\section{Motivation}
\label{sec:motivation}

The following Section will discuss or make reference to cryptographic concepts that may be foreign to the reader. Section  \ref{sec:crypto} provides detailed definitions of these concepts in a ground-up manner, and may prove helpful in illuminating some of the coming discussion.\\

There are several subfields that currently occupy the research space of post-quantum cryptography. These subfields are each predicated on their own underlying mathematical problems, and more importantly, assumptions on the difficulty of those problems.

The most common subfields of post-quantum cryptography are the following:
\begin{itemize}
\item \textit{Lattice-based Cryptography}. Within lattice-based cryptography there are two different approaches; default lattice-based crypto and its ring variant.
\item \textit{Hash-based Cryptography}. This particular branch is limited to the domain of digital signatures. Signature schemes designed in this paradigm employ cryptographic hash functions.
\item \textit{Multivariate Cryptography}.
\item \textit{Code-based Cryptography}.
\end{itemize}
For this dissertation, however, we will focus on a younger subfield of post-quantum cryptography, namely, isogeny-based cryptography. 

\noindent
\textit{Isogeny Based Cryptography}. Over the course of the past decade, elliptic curve cryptography (ECC) has proven itself a mainstay in the wide world of applied cryptology. While isogeny based cryptography and ECC are constructed from the same underlying field of mathematics, they differ in their fundamental presuppositions.

The aim of this dissertation is to improve the efficiency of a particular isogeny based scheme. We hope to showcase that, through intelligent implementation, isogeny based protocols still have a lot of improvement potential in terms of run-time and storage performance. 

Many post-quantum secure protocols suffer one dimension or another when compared to non-post-quantum protocols.

\subsection{Post-Quantum and Classical Performance Comparisons}

We will now provide a rough survey of the many post-quantum schemes and contrast their performance (both temporally in terms of exeuction time, and spatially in terms of key and signature sizes) with popular non-quantum-safe systems.\\

All of the following measurements reflect implementations which offer 128 bit post-quantum security, with the exception of classical protocols ECDH, RSA, and ECDSA, where numbers are taken at the 128-bit classical security level.

\noindent
\textit{Run-time Performance of Post-Quantum and Classical Protocols}.

\begin{figure}[!h]
\centering
\begin{minipage}{.5\textwidth}
	\centering
	\begin{tabular}{l | a }
	\hline
	\rowcolor{LightCyan}
	\mc{1}{} & \mc{1}{Cycles}\\
	\hline
	SIDH & c \\
	NTRU & c \\
	NewHope & c \\
	McEliece & c \\
	ECDH & c \\
	\hline
	\end{tabular}
	\captionof{figure}{Benchmarks for popular key-exchange protocols}
\end{minipage}%
\begin{minipage}{.5\textwidth}
	\centering
	\begin{tabular}{l | a | a | a }
	\hline
	\rowcolor{LightCyan}
	\mc{1}{}  & \mc{1}{Key Gen} & \mc{1}{Sign} & \mc{1}{Verify}\\
	\hline
	SIDH & a & b & c \\
	Sphincs & a & b & c \\
	Rainbow & a & b & c \\
	qTESLA & a & b & c \\
	Picnic & a & b & c \\
	RSA & a & b & c \\
	ECDSA & a & b & c \\
	\hline
	\end{tabular}
	\captionof{figure}{Benchmarks for popular signature schemes}
\end{minipage}
\end{figure}

\noindent
\textit{Key/Signature Sizes of Post-Quantum}.

\begin{center}
\begin{tabular}{l | a | a | a }
\hline
\rowcolor{LightCyan}
\mc{1}{}  & \mc{1}{Public Key} & \mc{1}{Private Key} & \mc{1}{Signature}\\
\hline
SIDH & 768 & b & 141,312 \\
Sphincs & 32 & 64 & 8,080 - 16,976 \\
Rainbow & 152,097 - 192,241 & 100,209 - 114,308 & 64 - 104 \\
qTESLA & 4,128 & 2,112 & 3,104 \\
Picnic & 33 & 49 & 34,004 - 53,933 \\
RSA & 384 & b & 384 \\
ECDSA & 32 & b & 32 \\
\hline
\end{tabular}
\end{center}

It's clear that isogeny based schemes have a long way to go in terms of temporal performance before they can hold their own against protocols such as \_\_\_ or even the post-quantum \_\_\_. The exceptionally small key sizes of SIDH and other isogeny-based schemes, however, are an advantage worth noting. 

\subsection{Performance History of Isogeny Based Cryptosystems}

Post-quantum cryptography has been the subject of rigorous research for over a decade now. 

Progress in the subfield of isogeny-based cryptography has been made slowly yet surely in this time, with the majority of its contributions arriving from one of two sources: the Institute for Quantum Computing (IQC) at Waterloo University, and the Microsoft Research team in \_\_\_. 

Most notably, this research is built upon an isogeny-based signature scheme published by Yoo et al. 

\section{Contributions}

We offer two main contributions to the Yoo et al. signature scheme implementation. Both of these contributions are designed with the intent of improving the performance of the Yoo et al. signature scheme: the first offers an improvement in the run-time of the signature scheme and the second 

All of these contributions can be found and tested at https://github.com/GorrieXIV/SIDH2.0-SignatureExtension .

\subsection{Protocol Performance}

Our first contribution involves the implementation of a procedure which batches together many occurances of the same low level operation.

We offer C code incorporating this batching procedure into the Yoo et al. signature scheme. Our implementation leverages the already parallel nature of the scheme to track the occurance of expensive operations that occur across multiple threads.

In the Section detailing this contribution, we offer extensive measurements of the performance increases offered by the inclusion of the batching procedure. We include also a discussion of other possible use-cases for operation batching in isogeny based schemes, not covered by out implementation.


\subsection{Signature Size}

The second contribution we offer comes in the form of an adoption of a particular compression algorithm into the Yoo et al. signature protocol. The compression algorithm in question, contrived by Costello et al. and outlined in \cite{pkcomp}, is intended for compression of SIDH public keys. We have adopted this method and applied it to specific portions of the Yoo et al. signatures, yielding significantly smaller signatures at the cost of extra computation.

We detail our C implementation of this compression on signatures in Section \ref{sec:compress}, and analyse both the decrease in signature size and the computational cost.

\section{Structure}

With the remaining Section of this introductory Chapter, we will disambiguate the forthcoming structure and syntax used in the dissertation.

\subsection{Layout}

This dissertation is divided into 5 Chapters. This Chapter and the one that follows contain the relevent preliminary information for understanding the contributions of the thesis. The two following Chapters thereafter outline in detail the two contributions of this dissertation. The 5$^{\text{th}}$ and final Chapter concludes the dissertation while offering any final remarks and suggestions for continued research.

Chapter 2 covers the relevant mathematics background and is far and away the longest Chapter. Within this Chapter we also cover the portions of the SIDH C library that are utilized and/or modified in our implementations. It is worth noting that thorough and complete coverage of this chapter is not necessary for a satisfactory understanding of our contributions, nor is it necessary for understanding the conclusions we come to make about the usefulness of our techniques, and of the studied isogeny-based signature scheme at large.

If, however, the reader desires to pursue isogeny-based cryptosystems in a research setting, then Chapter 2 will (hopefully) prove to be an effective and digestible surface-level introduction to this subfield.  

Chapters 3 \& 4 are rather similar in structure. Both begin with an introduction of their contribution's components - doing so in a general setting. Following this, the implementation specifics of the Chapters contribution are layed out. For these Sections, we attempt to convey the implementation details with a level of granularity we find easily accessible, while also providing enough information such that if the reader were to dive into the codebase they could do so comfortably. The final Sections of Chapters 4 \& 5 include the implementation results, benchmarks, and analysis. The main structural difference between these two Chapters is that Chapter 4 requires additional background. We found it more appropriate to include this material here, in the introduction to Chapter 4, rather than in Chapter 2.

\subsection{Notation \& Style}

We will now take some time for formalizing the variety of notation and formatting  used in this dissertation.\\

\noindent
\textit{General Conventions.} Throughout the text, \textit{italics} are used as a means of applying emphasis. This is done frequently to draw attention to newly introduced terms or to suggest the cadence of a sentence. Additionally, italics are employed to add further structure to (sub)sections; a non-indented paragraph following a horizontal space will often begin with an italicized term or concept. These italicized sentences denote the beginning of a new discussion topic.\\

\noindent
\textit{Functions \& Procedures}. Throughout the dissertation, general functions and procedures are denoted by the use of a \textbf{bold font face}. This is true for procedures introduced both formally and informally. Functions that are defined within the \sidh C codebase (either by us or others), however, are denoted by the use of a \code{monospace font}. This monospace notation is also sometimes used to denote routines or subroutines composed of by a sequence of functions or a portion of code. 

When referring to a function in any general sense, we will write only its name using the aforemention convention. By contrast, when we refer to the result of a function executed over input $x_{1}, ..., x_{n}$, we append on the function identifier the set of parameters enclosed in parathesis (e.g. \textbf{GenericFunction($x_{1}, ..., x_{n}$) or \code{GenericFunction($x_{1}, ..., x_{n}$)}}. 

It is also worth noting that we frequently refer to these abstract, bold-identified functions as \textit{procedures}, whereas we try to reserve use of the term \textit{function} for C-defined \sidh functions. When giving precise definitions of procedures, we opt for a pseudocode/algorithmic approach. For functions, on the otherhand, we enclose our definitions in an environment with a light-gray background. Consider the following: \\

\begin{algorithm}
\caption{-- \textbf{ProcedureExample($\{a_0, a_1, ... , a_b\}$, $c$)}}\label{alg:procedureexample}
\begin{algorithmic}[1]
\If{$c \leq b$}
	\State \Return $a_c$
\Else
	\State \Return $-1$
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{figure}[!h]
\label{code:pbinv}
\begin{lstlisting}
void function_example (int* a, int b, int c) {
	if (c <= b) {
		return a[c];
	} else {
		return -1;
	}
}
\end{lstlisting}
\caption{Function example.}
\end{figure}

\noindent
\textit{Cryptography Conventions}. Cryptographic protocols, as per the usual convention, are written and defined in terms of tuples of algorithms. In denoting general protocols, we frequently use a capital Pi ($\Pi$) subscripted with some informative title.

\noindent
\textit{Math Conventions}. In denoting isogonies (and other functions between elliptic curves) we will opt to use upper-case greek letters. Elliptic curves discussed in a general setting are refered to, when possible, as $E$; if a more unique identifier is necessary, $E$ with a unique subscript is used. For example, $E_{Alice}$ might refer to a curve created by Alice.  


